// scripts/backfill-rank-snapshots.ts
// One-time script: create 20 daily rank snapshots from ~600 -> 875 points
// Usage:
//   npx ts-node scripts/backfill-rank-snapshots.ts --studentId=<STUDENT_ID>
// or
//   STUDENT_ID=<id> npx ts-node scripts/backfill-rank-snapshots.ts

import { prisma } from '../src/lib/prisma';
import { randomInt } from 'crypto';

function usageAndExit() {
  console.error('Usage: npx ts-node scripts/backfill-rank-snapshots.ts --studentId=<STUDENT_ID>');
  process.exit(1);
}
function parseArgs(): { studentId: string } {
  let studentId: string | null = process.env.STUDENT_ID ?? null;

  if (!studentId) {
    for (const a of process.argv) {
      if (a.startsWith('--studentId=')) {
        studentId = a.slice('--studentId='.length);
        break;
      }
    }
  }

  if (!studentId) {
    console.error('Usage: npx ts-node scripts/backfill-rank-snapshots.ts --studentId=<STUDENT_ID>');
    process.exit(1);
  }

  return { studentId };
}



// Tier/division helpers: same mapping used by the app
const TIER_ORDER = [
  'IRON','BRONZE','SILVER','GOLD','PLATINUM','EMERALD','DIAMOND','MASTER','GRANDMASTER','CHALLENGER'
];
const DIV_ORDER = ['IV','III','II','I'] as const;

/** Convert points (linear) -> { tier, division, lp } */
function pointsToRank(points: number): { tier: string; division: string | null; lp: number } {
  if (points < 0) points = 0;
  const tierIdx = Math.floor(points / 400);
  const cappedTierIdx = Math.min(Math.max(tierIdx, 0), TIER_ORDER.length - 1);
  const tier = TIER_ORDER[cappedTierIdx];

  const inTier = points - cappedTierIdx * 400;

  if (cappedTierIdx >= TIER_ORDER.indexOf('MASTER')) {
    // master+ tiers have no divisions in this scale; treat remainder as LP
    return { tier, division: null, lp: Math.round(inTier) };
  }

  // divisions encoded so that:
  // DIV_ORDER = ['IV','III','II','I']
  // We used offset = (DIV_ORDER.length - 1 - divIdx) * 100 earlier.
  // So to decode:
  const bucket = Math.floor(inTier / 100); // 0 -> highest division index (I), 3 -> lowest (IV)
  const divIdx = Math.min(Math.max(DIV_ORDER.length - 1 - bucket, 0), DIV_ORDER.length - 1);
  const division = DIV_ORDER[divIdx];
  const divOffset = (DIV_ORDER.length - 1 - divIdx) * 100;
  const lp = Math.round(Math.max(0, inTier - divOffset));

  return { tier, division, lp };
}

async function main() {
  const { studentId } = parseArgs();

  // config
  const DAYS = 20;
  const startPoints = 600;
  const endPoints = 875;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // build 20 days evenly from start->end, with small jitter +/- 12 LP
  const rows: {
    studentId: string;
    capturedAt: Date;
    tier: string;
    division: string | null;
    lp: number;
  }[] = [];

  for (let i = 0; i < DAYS; i++) {
    const day = new Date(today);
    day.setDate(today.getDate() - (DAYS - 1 - i)); // oldest first -> today

    // linear progress from start -> end
    const t = i / (DAYS - 1);
    const base = Math.round(startPoints + (endPoints - startPoints) * t);

    // add small random fluctuation: [-12..+12]
    const jitter = randomInt(-12, 13);
    const pts = Math.max(0, base + jitter);

    const rank = pointsToRank(pts);

    rows.push({
      studentId,
      capturedAt: day,
      tier: rank.tier,
      division: rank.division,
      lp: rank.lp,
    });
  }

  console.log(`Inserting ${rows.length} snapshots for student ${studentId} (one-time) ...`);

  // Use createMany for efficiency. id is auto-generated by Prisma.
  // If you want to inspect before writing, comment out the following block.
  try {
    await prisma.rankSnapshot.createMany({
      data: rows.map(r => ({
        studentId: r.studentId,
        capturedAt: r.capturedAt,
        tier: r.tier,
        division: r.division,
        lp: r.lp,
      })),
      skipDuplicates: false,
    });
    console.log('Inserted OK.');
  } catch (err) {
    console.error('Insert failed:', err);
  } finally {
    await prisma.$disconnect();
  }
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
